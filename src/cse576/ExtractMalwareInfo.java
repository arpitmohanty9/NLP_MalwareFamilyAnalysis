package cse576;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.json.JSONArray;
import org.json.JSONObject;

public class ExtractMalwareInfo {
	final static String tempFile = "temporary_record.temp";
	static JSONArray ja = new JSONArray();

	public static void main(String[] args) throws Exception {
		long millis = System.currentTimeMillis();
		StringBuilder progOutput = new StringBuilder(
				"----------------------------------------------------------------------\n");
		System.out.println("--------------------------------------------------------------------------------------");
		if (args.length == 0) {
			System.out.println("Pass an Malware Name as cmd line.");
			return;
		}
		if (args.length > 2) {
			System.out.println("Too many arguments.\n"
					+ "Usage:\n"
					+ "<JavaCode> MalwareName [DepthToSearch]");
			return;
		}

		Queue<String> queueMalwareMain = new LinkedList<String>();
		Queue<String> queueMalwareTemp = new LinkedList<String>();
		ArrayList<String> processedMalware = new ArrayList<String>();
		int parentID = 1;
		int rootID = 1;
		int rootParent = 0;
		int ID = 2;
		int totalLevel = 1;
		int curLevel = 1;
		try {
			if (args.length == 2) {
				totalLevel = Integer.parseInt(args[1]);
			}
		} catch (NumberFormatException ex) {
			totalLevel = 1;
			System.out.println("Wrong arguments.\n"
					+ "Usage:\n"
					+ "<JavaCode> MalwareName [DepthToSearch]\n\n"
					+ "Took default: <JavaCode> "+ args[0] +" "+ totalLevel);
		}

		String path = Utility.getPath();
		SimpleDateFormat dateForm = new SimpleDateFormat("dd MMM, yyyy");

		String rootMalwareName = args[0];
		queueMalwareMain.add(rootMalwareName);
		while (true) {
			if (curLevel > totalLevel) {
				System.out.println("Complete");
				break;
			}
			if (queueMalwareMain.isEmpty()) {
				queueMalwareMain.addAll(queueMalwareTemp);
				queueMalwareTemp.clear();
				if (queueMalwareMain.isEmpty()) {
					System.out.println("Complete");
					break;
				}
				curLevel++;
				for (String s : queueMalwareMain) {
					System.out.println(s);
				}
				// break;
			}

			String malwareSearched = queueMalwareMain.remove().toLowerCase();
			if (ja != null && ja.length() != 0) {
				for (int i = 0; i < ja.length(); i++) {
					JSONObject jObj = ja.getJSONObject(i);
					if (jObj.getString("MalwareName").equalsIgnoreCase(malwareSearched)) {
						try {
							parentID = Integer.parseInt(jObj.getString("NodeID"));
						} catch (NumberFormatException ex) {

						}
						break;
					}
				}
			}

			System.out.println("Running Scrapper for " + malwareSearched);
			HashMap<String, String[]> pythonScriptResult = null;
			pythonScriptResult = Utility
					.runCommand("python \"" + path + "\\scraper\\main.py\" \"" + malwareSearched + "\"");

			File file = new File(path + "\\data\\" + malwareSearched + ".csv");
			if (!file.exists()) {
				System.out.println("Run the scraper first for " + malwareSearched);
				continue;
			}

			System.out.println("Scrapped records for " + malwareSearched);
			String[] records = Utility.readCSV(malwareSearched);
			String malware = malwareSearched;

			int count = 1;
			for (String record : records) {
				System.out.println("Processing record " + (count++) + " for " + malwareSearched);
				// Utility.getParsedJson(record, malwareSearched, count++);

				StringBuilder basename = new StringBuilder();
				String knownas = "([Kk]nown as (\\w+))|([vV]ariant (\\w+))";

				Pattern p = Pattern.compile(knownas);
				Matcher matcher = p.matcher(record);

				boolean firstMatch = true;
				while (matcher.find()) {
					if (!firstMatch) {
						basename.append(":");
					} else {
						firstMatch = false;
					}
					if (matcher.group(2) == null) {
						basename.append(matcher.group(4));
					} else {
						basename.append(matcher.group(2));
					}
				}

				FileOutputStream out = new FileOutputStream(tempFile);
				out.write(record.getBytes());
				out.close();

				pythonScriptResult = Utility.runCommand("python \"" + path + "\\python\\getMalwareName.py\" \"" + path
						+ "\\" + tempFile + "\" \"" + basename + "\"");
				if (pythonScriptResult != null) {
					HashMap<String, String> extractedData = new HashMap<String, String>();
					String[] output = pythonScriptResult.get("OUTPUT");
					if (output == null || output.length == 0) {
						for (String str : pythonScriptResult.get("ERROR")) {
							System.out.println(str);
						}
						continue;
					}

					for (String str : output) {
						String[] tmp = str.split(" :::: ");
						if (tmp.length != 2) {
							// Ignore that line
							continue;
						}
						extractedData.put(tmp[0], tmp[1]);
					}

					if (extractedData.get("Name") != null) {
						malware = extractedData.get("Name");
					}
				}

				String semanticRoles = null, target = null, tools = null;
				String[] targetList = null, toolsList = null;
				pythonScriptResult = Utility.runCommand(
						"python \"" + path + "\\python\\labelSemanticRole.py\" \"" + path + "\\" + tempFile + "\"");
				if (pythonScriptResult != null) {
					HashMap<String, String> extractedData = new HashMap<String, String>();
					String[] output = pythonScriptResult.get("OUTPUT");
					if (output == null || output.length == 0) {
						for (String str : pythonScriptResult.get("ERROR")) {
							System.out.println(str);
						}
						continue;
					}

					for (String str : output) {
						String[] tmp = str.split(" :::: ");
						if (tmp.length != 2) {
							// Ignore that line
							continue;
						}
						if (tmp[0].equalsIgnoreCase("SemanticRoleLabel")) {
							String label = extractedData.get("SemanticRoleLabel");
							if (label != null) {
								if (!tmp[1].equals("[]")) {
									extractedData.put(tmp[0], label + "\n" + tmp[1]);
								}
							} else {
								extractedData.put(tmp[0], tmp[1]);
							}
						} else {
							extractedData.put(tmp[0], tmp[1]);
						}

					}

					if (extractedData.get("SemanticRoleLabel") != null) {
						semanticRoles = extractedData.get("SemanticRoleLabel");
					}
					if (extractedData.get("Target") != null) {
						targetList = extractedData.get("Target").split(":-----:");
						ArrayList<String> temp = new ArrayList<String>(Arrays.asList(targetList));
						temp.removeAll(Arrays.asList(""));
						targetList = temp.toArray(new String[0]);
					}
					if (extractedData.get("Tools") != null) {
						toolsList = extractedData.get("Tools").split(":-----:");
						ArrayList<String> temp = new ArrayList<String>(Arrays.asList(toolsList));
						temp.removeAll(Arrays.asList(""));
						toolsList = temp.toArray(new String[0]);
					}
				}

				HashMap<String, Object> resultDateCVE = DateCVEfromReport.ExtractDateCVE(record);
				Date foundDate = (Date) resultDateCVE.get("DATE");
				Set<?> listCVETmp = null;
				String[] listCVE = null;
				Object cve = resultDateCVE.get("CVE");
				if (cve instanceof ArrayList<?>) {
					ArrayList<?> temp = (ArrayList<?>) cve;
					listCVETmp = new HashSet<>(temp);
				}

				if (listCVETmp != null && listCVETmp.size() > 0) {
					listCVE = listCVETmp.toArray(new String[listCVETmp.size()]);
				}

				if (toolsList != null && toolsList.length > 0) {
					tools = toolsList[0].trim();
					for (int i = 1; i < toolsList.length; i++) {
						tools += "\n                  " + toolsList[i].trim();
					}
				}
				if (targetList != null && targetList.length > 0) {
					target = targetList[0].trim();
					for (int i = 1; i < targetList.length; i++) {
						target += "\n                  " + targetList[i].trim();
					}
				}

				System.out.println("Malware Name: " + malware);
				System.out.println("Date Found: " + dateForm.format(foundDate));
				System.out.println("CVE Exploited: " + Utility.ArrayToString(listCVE));
				System.out.println("Related Malware: " + malwareSearched.substring(0, 1).toUpperCase()
						+ malwareSearched.substring(1));
				System.out.println("RoleLabel: " + semanticRoles);
				System.out.println("Target: " + target);
				System.out.println("Tools: " + tools);
				System.out.println("----------------------------------------------------------------------");

				boolean found = false;

				for (int i = 0; i < ja.length(); i++) {
					JSONObject jObj = ja.getJSONObject(i);
					if (jObj.getString("MalwareName").equalsIgnoreCase(malware)) {
						Date before = dateForm.parse(jObj.getString("DateFound"));
						if (foundDate.before(before)) {
							jObj.put("DateFound", dateForm.format(foundDate));
						}
						StringBuilder strBuildedrTemp = new StringBuilder(jObj.getString("ExploitedCVE"));
						String exploited = Utility.ArrayToString(listCVE);
						if (strBuildedrTemp.toString().length() != 0 && !exploited.equals("")) {
							strBuildedrTemp.append(", ");
						}
						strBuildedrTemp.append(exploited);
						jObj.put("ExploitedCVE", strBuildedrTemp.toString());

						strBuildedrTemp = new StringBuilder(jObj.getString("Target"));
						if (strBuildedrTemp.length() != 0 && target != null) {
							strBuildedrTemp.append(", ");
						}
						if (target != null)
							strBuildedrTemp.append(target);
						jObj.put("Target", strBuildedrTemp.toString());

						strBuildedrTemp = new StringBuilder(jObj.getString("Tools"));
						if (strBuildedrTemp.length() != 0 && tools != null) {
							strBuildedrTemp.append(", ");
						}
						if (tools != null)
							strBuildedrTemp.append(tools);
						jObj.put("Tools", strBuildedrTemp.toString());

						found = true;
						break;
					}
				}

				if (!found) {
					JSONObject jo = new JSONObject();
					jo.put("MalwareName", malware);
					jo.put("DateFound", dateForm.format(foundDate));
					jo.put("ExploitedCVE", Utility.ArrayToString(listCVE));
					if (target != null)
						jo.put("Target", target);
					else
						jo.put("Target", "");
					if (tools != null)
						jo.put("Tools", tools);
					else
						jo.put("Tools", "");

					if (malware.equalsIgnoreCase(rootMalwareName)) {
						jo.put("Level", Integer.toString(curLevel));
						jo.put("NodeID", Integer.toString(rootID));
						jo.put("ParentID", Integer.toString(rootParent));
					} else {
						jo.put("Level", Integer.toString(curLevel + 1));
						jo.put("NodeID", Integer.toString(ID++));
						jo.put("ParentID", Integer.toString(parentID));
					}
					ja.put(jo);
					if (curLevel < totalLevel && !malware.equalsIgnoreCase(malwareSearched)
							&& !processedMalware.contains(malware)) {
						queueMalwareTemp.add(malware);
					}
				}

			}
			processedMalware.add(malwareSearched);
			if (curLevel == 1) {
				ja = Utility.jsonArraySorting(ja, "NodeID");
				JSONObject jsonobject = ja.getJSONObject(0);
				if (!jsonobject.getString("ParentID").equals("0")) {
					jsonobject.put("Level", Integer.toString(curLevel));
					jsonobject.put("NodeID", Integer.toString(parentID));
					jsonobject.put("ParentID", Integer.toString(rootParent));
				}
			}
		}

		System.out.println("\n\n Complete Processing \n\n");

		ja = Utility.jsonArraySorting(ja, "NodeID");
		for (int i = 0; i < ja.length(); i++) {
			JSONObject jsonobject = ja.getJSONObject(i);
			@SuppressWarnings("unchecked")
			Iterator<String> keys = jsonobject.keys();
			while (keys.hasNext()) {
				String keyValue = (String) keys.next();
				String valueString = jsonobject.getString(keyValue);
				String key = String.format("%15s", keyValue);
				progOutput.append(key + " : " + valueString + "\n");
				System.out.println(key + " | " + valueString);
			}
			progOutput.append("----------------------------------------------------------------------\n");
			System.out.println("----------------------------------------------------------------------------------");
		}

		millis = System.currentTimeMillis() - millis;
		String timeTaken = String.format("%02d min, %02d sec", TimeUnit.MILLISECONDS.toMinutes(millis),
				TimeUnit.MILLISECONDS.toSeconds(millis)
						- TimeUnit.MINUTES.toSeconds(TimeUnit.MILLISECONDS.toMinutes(millis)));

		System.out.println("Total Time Taken: " + timeTaken);
		String filePath = path + "/program_output.output";
		try (BufferedWriter bw = new BufferedWriter(new FileWriter(filePath))) {
			bw.write(progOutput.toString());
			// bw.write("\n\n\nTotal Time Taken: " + timeTaken + "\n\n");
			// no need to close it.
			// bw.close();
		} catch (IOException e) {
			e.printStackTrace();
		}

		System.exit(0);
	}
}
