import sys

from nltk.stem import WordNetLemmatizer

from practnlptools.tools import Annotator


def semantic_role_label():
    lemmatizer = WordNetLemmatizer()
    verbs_target = ["ensnare", "infect", "use", "target"]
    verbs_tool = ["attack"]

    # sent = "Mirai-Based Masuta Botnet Weaponizes Old Router Vulnerability. By Ionut Arghire on January 24, 2018. inShare. A new piece of malware based on Mirai's publicly released source code has been observed at large, ensnaring devices into a botnet, targeted Internet of Things. Known as Masuta, the botnet has at least two variants at large, and is believed to be the work of a well-known IoT threat actor, NewSky Security says. What?s also unique to the botnet is that it exploits an old router vulnerability, being the first threat known to weaponize it in a botnet campaign. Masuta (Japanese for master) botnet?s source code was found on an invite only dark forum. The malware?s configuration file, the researchers discovered, uses a different seed of the cipher key compared to Mirai, having the strings in the configuration files XORed by 0x45. Thus, the researchers discovered that it uses the domain nexusiotsolutions(dot)net, the command and control (C&C) server that Nexus Zeta, the individual involved in the recent Satori attacks, uses. The domain was registered using the nexuszeta1337@gmail(.)com email address. Thus, NewSky Security suggests that Nexus Zeta has been involved in the creation of the Masuta botnet, in addition to building Satori, the Mirai variant that has been wreaking havoc over the past couple of months. In fact, Masuta isn?t new either, and attacks involving it have been steadily increasing since September, and the botnet?s standard variant has been observed using several known/weak/default credentials to compromise IoT devices. An evolved variant of Masuta, called PureMasuta, contains the most typical of Mirai style code, and a list of weak credentials to use. What makes this malware variant stand out, however, is its usage of EDB 38722 D-Link exploit. The exploit PureMasuta uses resides in the HNAP (Home Network Administration Protocol), which is based on the SOAP protocol. It is possible to craft a SOAP query to bypass authentication by using hxxp://purenetworks.com/HNAP1/GetDeviceSettings, and improper string handling can lead to arbitrary code execution, and an attacker can abuse this combination of issues to run code on targeted devices. What the botnet does is to download a shell script from the C&C server and run it. Thus, the malware author first bypasses authentication and then executes code on the targeted devices. The PureMasuta variant uses the same C&C server (93.174.93.63) as the original Masuta variant, which led the researchers to believe it is the evolved creation of the same threat actor. Nexus Zeta is no stranger when it comes to implementing SOAP related exploits. The threat actor has already been observed in implementing two other known SOAP related exploits, CVE-2014-8361 and CVE-2017-17215 in his Satori botnet project, NewSky Security notes. Thus, the TR-069 bug and EDB 38722 are the third and fourth SOAP related exploits abused by IoT botnets. Protocol exploits are more desirable for threat actors as they usually have a wider scope. A protocol can be implemented by various vendors/models and a bug in the protocol itself can get carried on to a wider range of devices, the researchers conclude."

    # sent = "Mirai, the infamous botnet used in the recent massive distributed denial of service (DDoS) attacks against Brian Krebs' blog and Dyn's DNS infrastructure, has ensnared Internet of Things (IoT) devices in 164 countries, researchers say."

    if len(sys.argv) != 2:
        print("NOPE")
        exit()

    sent = sys.argv[1]

    target = ""
    tools = ""

    for s in [i.strip() for i in sent.split(".")]:
        a = Annotator()
        b = a.getAnnotations(s.encode('utf-8'))

        dictlist = b['srl']
        for dict in dictlist:
            if 'V' in dict:
                if lemmatizer.lemmatize(dict["V"].lower(), 'v') in verbs_target:
                    temp = ""
                    if "A0" in dict:
                        temp += dict['A0']
                    temp += " :|: "
                    if "A1" in dict:
                        temp += dict['A1']
                    target += "[" + temp + "]    "
                if lemmatizer.lemmatize(dict["V"].lower(), 'v') in verbs_tool:
                    temp = ""
                    if "A0" in dict:
                        temp += dict['A0']
                    temp += "|"
                    if "A1" in dict:
                        temp += dict['A1']
                    tools += "[" + temp + "]    "

        # print("SemanticRoleLabel :::: {}".format(b['srl']))
        # print("2nd:\n{}".format([x, y] for x,y in [b['ner']]))

    print("Target :::: " + target)
    print("Tools :::: " + tools)


if __name__ == '__main__':
    semantic_role_label()
